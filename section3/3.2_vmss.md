### 3.2 Virtual Machine Scale Sets (VMSS)

**⚠️ Concept Clé pour AZ-104 : VMSS est la solution pour déployer et gérer des groupes de VMs identiques avec scaling automatique**

**Définition :**
- **Virtual Machine Scale Sets (VMSS)** : Groupe de VMs identiques gérées comme une seule unité
- **Scaling automatique** : Augmente/réduit le nombre d'instances selon la demande
- **Load balancing** : Distribution automatique du trafic entre instances
- **High availability** : Distribution dans Fault Domains et Update Domains
- **Use Case** : Applications web scalables, traitement par lots, microservices

#### Architecture VMSS

```
┌───────────────────────────────────────────────┐
│       Virtual Machine Scale Set (VMSS)        │
├───────────────────────────────────────────────┤
│  Azure Load Balancer / Application Gateway    │
│              ↓                                │
│  ┌─────────────────────────────────────────┐  │
│  │        VM Instances (identiques)        │  │
│  │  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐    │  │
│  │  │ VM 1 │ │ VM 2 │ │ VM 3 │ │ VM 4 │    │  │
│  │  └──────┘ └──────┘ └──────┘ └──────┘    │  │
│  │  Fault Domain 0    Fault Domain 1       │  │
│  │  Update Domain 0-1 Update Domain 2-3    │  │
│  └─────────────────────────────────────────┘  │
└───────────────────────────────────────────────┘
```

**Caractéristiques Principales :**
- ✅ **Instances identiques** : Toutes créées à partir de la même image
- ✅ **Scaling** : Manuel, automatique, ou programmé
- ✅ **High availability** : Distribution FD/UD automatique
- ✅ **Load balancing** : Intégration native Load Balancer/Application Gateway
- ✅ **Upgrade policies** : Contrôle des mises à jour

#### Orchestration Modes (⚠️ Important pour l'Examen)

**1. Uniform Orchestration (Mode par Défaut)**

**Caractéristiques :**
- ✅ **Instances identiques** : Toutes VMs strictement identiques (même taille, même configuration)
- ✅ **Scaling automatique** : Supporté nativement
- ✅ **Load balancer** : Intégration automatique
- ✅ **Overprovisioning** : Crée temporairement plus d'instances pour accélérer le déploiement
- ❌ **Limitation** : Impossible de mixer différentes tailles de VMs

**Cas d'usage :**
- Applications web stateless
- Workloads nécessitant scaling rapide
- Instances interchangeables

**Exemple création Uniform :**
```bash
az vmss create \
  --resource-group myRG \
  --name myVMSS \
  --image UbuntuLTS \
  --orchestration-mode Uniform \
  --upgrade-policy-mode Automatic \
  --instance-count 3 \
  --vm-sku Standard_D2s_v3 \
  --admin-username azureuser \
  --generate-ssh-keys \
  --load-balancer myLB
```

**2. Flexible Orchestration**

**Caractéristiques :**
- ✅ **VMs hétérogènes** : Mélanger différentes tailles de VMs
- ✅ **Instances existantes** : Ajouter des VMs existantes au scale set
- ✅ **Fault Domain spread** : Distribution avancée
- ⚠️ **Scaling** : Nécessite configuration manuelle
- ❌ **Overprovisioning** : Non supporté

**Cas d'usage :**
- Workloads complexes nécessitant différentes tailles de VMs
- Migration progressive vers VMSS
- Applications avec tiers variés

**Exemple création Flexible :**
```bash
az vmss create \
  --resource-group myRG \
  --name myFlexVMSS \
  --orchestration-mode Flexible \
  --platform-fault-domain-count 3 \
  --image UbuntuLTS \
  --admin-username azureuser \
  --generate-ssh-keys
```

**Comparaison Modes :**

| Caractéristique | Uniform | Flexible |
|-----------------|---------|----------|
| **VMs identiques** | ✅ Oui (obligatoire) | ❌ Non (tailles variées possibles) |
| **Autoscaling** | ✅ Natif | ⚠️ Manuel ou custom |
| **Load Balancer integration** | ✅ Automatique | ⚠️ Manuel |
| **Overprovisioning** | ✅ Oui | ❌ Non |
| **VMs existantes** | ❌ Non | ✅ Oui |
| **Complexity** | ✅ Simple | ⚠️ Plus complexe |
| **Use Case** | Web apps, scaling rapide | Workloads mixtes |

#### Upgrade Policies (⚠️ Très Important pour l'Examen)

**⚠️ Erreur Courante QCM : Comprendre les différentes upgrade policies**

**1. Automatic Upgrade Policy**

**Comportement :**
- Azure applique automatiquement les mises à jour
- Redémarre instances progressivement (batch par batch)
- Respecte les Update Domains

**Avantages :**
- ✅ **Effort minimal** : Aucune intervention manuelle
- ✅ **Rolling update** : Pas de downtime total
- ✅ **Rapide** : Déploiement automatique

**Inconvénients :**
- ❌ **Contrôle limité** : Pas de validation avant MAJ
- ⚠️ **Risque** : Bug peut impacter toutes les instances

**Cas d'usage :**
- Environnements de développement/test
- Applications simples
- Confiance totale dans la nouvelle version

```bash
az vmss create \
  --resource-group myRG \
  --name myVMSS \
  --upgrade-policy-mode Automatic \
  --image UbuntuLTS \
  --instance-count 5
```

**2. Rolling Upgrade Policy**

**Comportement :**
- Mise à jour par **batch** (groupe d'instances)
- **Health probes** : Valide santé avant de continuer
- **Pause** entre chaque batch configurable
- Rollback automatique si échec détecté

**Configuration :**
```json
{
  "upgradePolicy": {
    "mode": "Rolling",
    "rollingUpgradePolicy": {
      "maxBatchInstancePercent": 20,
      "maxUnhealthyInstancePercent": 20,
      "maxUnhealthyUpgradedInstancePercent": 20,
      "pauseTimeBetweenBatches": "PT5M"
    }
  }
}
```

**Paramètres :**
- **maxBatchInstancePercent** : % d'instances mises à jour simultanément (ex: 20% = 1 instance sur 5)
- **maxUnhealthyInstancePercent** : % max d'instances malsaines tolérées
- **pauseTimeBetweenBatches** : Délai entre batches (PT5M = 5 minutes)

**Avantages :**
- ✅ **Contrôle** : Validation par batch
- ✅ **Sécurité** : Health checks avant continuation
- ✅ **Rollback** : Automatique si échec

**Cas d'usage :**
- **Production** : Application critique
- **Validation** : Tests progressifs
- **Risk mitigation** : Minimiser impact des bugs

```bash
az vmss update \
  --resource-group myRG \
  --name myVMSS \
  --set upgradePolicy.mode=Rolling
```

**3. Manual Upgrade Policy**

**Comportement :**
- ❌ **Aucune mise à jour automatique**
- Vous devez **manuellement** mettre à jour chaque instance
- Contrôle total sur le timing et l'ordre

**Avantages :**
- ✅ **Contrôle total** : Vous décidez quand et comment
- ✅ **Validation** : Tester instance par instance
- ✅ **Zero risk** : Pas de surprise automatique

**Inconvénients :**
- ❌ **Effort élevé** : Intervention manuelle requise
- ⏱️ **Lent** : Processus manuel long
- ⚠️ **Risque d'oubli** : Instances pas à jour

**Cas d'usage :**
- **Applications critiques** : Nécessitant validation manuelle poussée
- **Compliance** : Exigences réglementaires strictes
- **Blue/Green deployment** : Contrôle fin

**Mise à jour manuelle :**
```bash
# Lister les instances
az vmss list-instances \
  --resource-group myRG \
  --name myVMSS \
  --output table

# Mettre à jour une instance spécifique
az vmss update-instances \
  --resource-group myRG \
  --name myVMSS \
  --instance-ids 0 1 2
```

**Matrice de Décision - Upgrade Policies :**

| Scénario | Policy Recommandée | Raison |
|----------|-------------------|--------|
| **App dev/test** | Automatic | Rapidité, effort minimal |
| **App production critique** | Rolling | Balance contrôle/automatisation |
| **Compliance stricte** | Manual | Contrôle total |
| **Déploiement continu CI/CD** | Rolling | Validation automatisée |
| **Application stateful** | Manual | Contrôle précis |

#### Health Monitoring (⚠️ Clé pour Rolling Upgrades)

**Application Health Extension :**

Surveillance de la santé des instances pendant les mises à jour.

**Configuration :**
```bash
az vmss extension set \
  --resource-group myRG \
  --vmss-name myVMSS \
  --name ApplicationHealthLinux \
  --publisher Microsoft.ManagedServices \
  --version 1.0 \
  --settings '{"protocol": "http", "port": 80, "requestPath": "/health"}'
```

**Health Probe Types :**
- **HTTP probe** : Requête HTTP vers endpoint (ex: /health)
- **TCP probe** : Connexion TCP sur port
- **Guest VM agent** : Statut de l'agent Azure

**Exemple endpoint health check (Node.js) :**
```javascript
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'healthy' });
});
```

#### Scaling Strategies

**⚠️ Erreur Courante QCM : Comprendre les différents types de scaling**

**1. Manual Scaling**

**Définition :** Augmenter/réduire manuellement le nombre d'instances.

```bash
# Scaler manuellement à 10 instances
az vmss scale \
  --resource-group myRG \
  --name myVMSS \
  --new-capacity 10

# Via Portal
VMSS → Scaling → Manual scale → Ajuster le nombre d'instances
```

**Cas d'usage :**
- Événements prévus (Black Friday, lancement produit)
- Applications avec trafic prévisible
- Environnements de développement

**2. Autoscale (Metric-based Scaling)**

**Définition :** Scaling automatique basé sur des métriques (CPU, RAM, requêtes HTTP, etc.).

**Configuration Autoscale :**
```bash
# Créer une règle d'autoscale
az monitor autoscale create \
  --resource-group myRG \
  --resource myVMSS \
  --resource-type Microsoft.Compute/virtualMachineScaleSets \
  --name autoscale-rule \
  --min-count 2 \
  --max-count 10 \
  --count 2

# Règle Scale Out (CPU > 70%)
az monitor autoscale rule create \
  --resource-group myRG \
  --autoscale-name autoscale-rule \
  --condition "Percentage CPU > 70 avg 5m" \
  --scale out 1 \
  --cooldown 5

# Règle Scale In (CPU < 30%)
az monitor autoscale rule create \
  --resource-group myRG \
  --autoscale-name autoscale-rule \
  --condition "Percentage CPU < 30 avg 5m" \
  --scale in 1 \
  --cooldown 5
```

**Métriques Communes :**
- **CPU Percentage** : % utilisation CPU
- **Memory Percentage** : % utilisation RAM (nécessite agent)
- **Disk Operations/sec** : IOPS disque
- **Network In/Out** : Bande passante réseau
- **Custom Metrics** : Application Insights (ex: requêtes HTTP/sec)

**Paramètres Clés :**
- **Threshold** : Seuil de déclenchement (ex: CPU > 70%)
- **Duration** : Durée avant déclenchement (ex: avg 5m)
- **Cooldown** : Délai avant nouvelle action (éviter flapping)
- **Scale action** : Nombre d'instances à ajouter/retirer

**Best Practice Autoscale :**
```
✅ Min instances : 2 (high availability)
✅ Scale out threshold : 70-75% CPU
✅ Scale in threshold : 25-30% CPU
✅ Cooldown : 5-10 minutes
✅ Increment : 1-2 instances à la fois
⚠️ Max instances : Définir limite pour contrôler coûts
```

**3. Scheduled Scaling (Time-based Scaling)**

**Définition :** Scaling programmé selon un horaire (jour/heure).

**Configuration :**
```bash
# Scale Out à 10 instances tous les lundis à 9h
az monitor autoscale rule create \
  --resource-group myRG \
  --autoscale-name autoscale-rule \
  --scale to 10 \
  --condition "time Monday 09:00"

# Scale In à 2 instances tous les vendredis à 18h
az monitor autoscale rule create \
  --resource-group myRG \
  --autoscale-name autoscale-rule \
  --scale to 2 \
  --condition "time Friday 18:00"
```

**Cas d'usage :**
- Applications avec trafic prévisible (heures bureau vs nuit)
- E-commerce (pics aux heures de pointe)
- Services B2B (actifs uniquement en semaine)

**Exemple Profil Scheduled :**
```json
{
  "profiles": [
    {
      "name": "Business Hours",
      "capacity": {
        "minimum": "5",
        "maximum": "20",
        "default": "5"
      },
      "recurrence": {
        "frequency": "Week",
        "schedule": {
          "days": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"],
          "timeZone": "Romance Standard Time",
          "hours": [8],
          "minutes": [0]
        }
      }
    },
    {
      "name": "Off Hours",
      "capacity": {
        "minimum": "2",
        "maximum": "5",
        "default": "2"
      },
      "recurrence": {
        "frequency": "Week",
        "schedule": {
          "days": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"],
          "timeZone": "Romance Standard Time",
          "hours": [18],
          "minutes": [0]
        }
      }
    }
  ]
}
```

**4. Predictive Autoscale (Azure ML-based)**

**Définition :** Scaling basé sur des prédictions Machine Learning du trafic futur.

**Avantages :**
- ✅ Anticipe les pics de trafic
- ✅ Scaling proactif (vs réactif)
- ✅ Optimise coûts et performance

**Activation :**
```bash
az monitor autoscale update \
  --resource-group myRG \
  --name autoscale-rule \
  --set predictiveAutoscalePolicy.scaleMode=Enabled
```

#### Cas d'Usage Typiques (⚠️ Scénarios d'Examen)

**Scénario 1 : Garantir Disponibilité Pendant Maintenance Azure**

**Question :**
> Vous avez une application qui nécessite **8 instances minimum** disponibles en permanence, même pendant les maintenances Azure. Quelle solution ?

**Réponse :** Créer un **VMSS avec 10 instances** minimum (ou plus)

**Justification :**
- Azure maintient un VMSS par **Update Domain**
- Avec 5 Update Domains (défaut), maximum **20% des instances** sont redémarrées simultanément
- 10 instances × 80% = **8 instances disponibles minimum** pendant maintenance
- **Upgrade Policy: Rolling** recommandé

```bash
az vmss create \
  --resource-group myRG \
  --name myVMSS \
  --image UbuntuLTS \
  --instance-count 10 \
  --upgrade-policy-mode Rolling \
  --platform-fault-domain-count 3 \
  --platform-update-domain-count 5
```

**Scénario 2 : Application Web avec Pics de Trafic Variables**

**Question :**
> Application web avec trafic 100 req/s (normal) et pics à 500 req/s (imprévisibles). Comment scaler automatiquement ?

**Réponse :** **Autoscale basé sur HTTP requests/sec** (custom metric)

```bash
# Configuration autoscale avec custom metric
az monitor autoscale create \
  --resource-group myRG \
  --resource myVMSS \
  --resource-type Microsoft.Compute/virtualMachineScaleSets \
  --name http-autoscale \
  --min-count 2 \
  --max-count 20 \
  --count 2

az monitor autoscale rule create \
  --resource-group myRG \
  --autoscale-name http-autoscale \
  --condition "Requests per instance > 100 avg 5m" \
  --scale out 2 \
  --cooldown 5
```

**Scénario 3 : E-Commerce avec Trafic Prévisible**

**Question :**
> Site e-commerce : Trafic faible nuit (2-4h), moyen journée (9-18h), pic soirée (19-23h). Comment optimiser coûts ?

**Réponse :** **Scheduled Scaling** avec profils horaires

```bash
# Profil Nuit (2 instances)
az monitor autoscale rule create \
  --resource-group myRG \
  --autoscale-name ecommerce-autoscale \
  --scale to 2 \
  --condition "time * 00:00"

# Profil Journée (5 instances)
az monitor autoscale rule create \
  --resource-group myRG \
  --autoscale-name ecommerce-autoscale \
  --scale to 5 \
  --condition "time * 09:00"

# Profil Soirée (10 instances)
az monitor autoscale rule create \
  --resource-group myRG \
  --autoscale-name ecommerce-autoscale \
  --scale to 10 \
  --condition "time * 19:00"
```

#### Networking et Load Balancing

**Load Balancer Integration :**

VMSS s'intègre nativement avec Azure Load Balancer.

```bash
# Créer VMSS avec Load Balancer
az vmss create \
  --resource-group myRG \
  --name myVMSS \
  --image UbuntuLTS \
  --instance-count 3 \
  --vnet-name myVNet \
  --subnet mySubnet \
  --lb myLoadBalancer \
  --backend-pool-name myBackendPool \
  --upgrade-policy-mode Rolling
```

**NAT Rules (Accès Individuel aux Instances) :**

Pour accéder individuellement aux instances (ex: SSH/RDP).

```bash
# Créer NAT rules
az network lb inbound-nat-rule create \
  --resource-group myRG \
  --lb-name myLoadBalancer \
  --name natRule0 \
  --protocol Tcp \
  --frontend-port 50000 \
  --backend-port 22 \
  --frontend-ip-name LoadBalancerFrontEnd

# Accès : ssh user@lb-ip -p 50000 (vers instance 0)
# Accès : ssh user@lb-ip -p 50001 (vers instance 1)
```

#### Gestion des Instances

**Lister les Instances :**
```bash
# Lister toutes les instances
az vmss list-instances \
  --resource-group myRG \
  --name myVMSS \
  --output table

# Afficher détails instance spécifique
az vmss get-instance-view \
  --resource-group myRG \
  --name myVMSS \
  --instance-id 0
```

**Redémarrer des Instances :**
```bash
# Redémarrer instance spécifique
az vmss restart \
  --resource-group myRG \
  --name myVMSS \
  --instance-ids 0 1

# Redémarrer toutes les instances
az vmss restart \
  --resource-group myRG \
  --name myVMSS \
  --instance-ids '*'
```

**Supprimer une Instance :**
```bash
az vmss delete-instances \
  --resource-group myRG \
  --name myVMSS \
  --instance-ids 2
```

**Protection des Instances :**

Empêcher une instance d'être modifiée par scale-in ou upgrades.

```bash
# Protéger contre scale-in
az vmss update \
  --resource-group myRG \
  --name myVMSS \
  --instance-id 0 \
  --protect-from-scale-in true

# Protéger contre scale-set actions
az vmss update \
  --resource-group myRG \
  --name myVMSS \
  --instance-id 0 \
  --protect-from-scale-set-actions true
```

#### Custom Script Extension (⚠️ Important pour Configuration)

Installation automatique de logiciels lors de la création des instances.

```bash
az vmss extension set \
  --resource-group myRG \
  --vmss-name myVMSS \
  --name CustomScriptExtension \
  --publisher Microsoft.Compute \
  --version 1.10 \
  --settings '{"fileUris": ["https://raw.githubusercontent.com/.../install.sh"], "commandToExecute": "./install.sh"}'
```

**Exemple script d'installation (install.sh) :**
```bash
#!/bin/bash
apt-get update
apt-get install -y nginx
systemctl start nginx
systemctl enable nginx
```

#### Comparaison VMSS vs Availability Sets

| Critère | VMSS | Availability Sets |
|---------|------|-------------------|
| **Scaling** | ✅ Automatique | ❌ Non (taille fixe) |
| **Instances** | Identiques | Peuvent différer |
| **Load Balancing** | ✅ Intégré | ⚠️ Séparé (à configurer) |
| **Gestion** | Unité unique | VMs individuelles |
| **Use Case** | Apps scalables | VMs fixes, différentes |
| **Max instances** | 1000 | 200 |
| **Cost** | Optimisé (scale-in) | Fixe |

#### Limites et Quotas VMSS

| Ressource | Limite | Notes |
|-----------|--------|-------|
| **Instances par VMSS (Uniform)** | 1000 | Standard images |
| **Instances par VMSS (Custom image)** | 600 | Images personnalisées |
| **Instances par VMSS (Flexible)** | 1000 | Par défaut |
| **VMSS par subscription** | 200 | Par région |
| **Data disks par instance** | 64 | Dépend de la VM size |
| **Update Domains** | 20 | Maximum |

#### Best Practices VMSS

**À FAIRE :**
- Utiliser **Managed Disks** (toujours)
- Configurer **Health Probes** pour Rolling upgrades
- Définir **Min/Max instances** pour autoscale
- Utiliser **Rolling upgrade policy** en production
- Configurer **Cooldown periods** (5-10 min)
- Activer **Overprovisioning** (Uniform mode)
- Utiliser **Custom Script Extension** pour configuration
- Monitorer avec **Azure Monitor**
- Tester **scale-in** avant production (éviter perte de données)

**À ÉVITER :**
- Oublier de configurer health checks (Rolling upgrades échoueront)
- Autoscale sans **max limit** (coûts incontrôlés)
- Scale-in trop agressif (impact performance)
- Utiliser **Manual upgrade policy** sans raison valide
- Ignorer **cooldown periods** (flapping)
- Hardcoder configuration dans images (utiliser Custom Script Extension)

#### Scénarios d'Examen AZ-104 - Récapitulatif

| Question Type | Réponse | Justification |
|---------------|---------|---------------|
| **Garantir 8 VMs pendant maintenance** | VMSS 10 instances | 20% max offline (Update Domains) |
| **Scaling automatique CPU** | Autoscale metric-based | Réactif aux métriques |
| **Trafic prévisible jour/nuit** | Scheduled scaling | Optimise coûts |
| **Application critique, validation MAJ** | Rolling upgrade policy | Health checks + batching |
| **Dev/Test, MAJ rapide** | Automatic upgrade policy | Effort minimal |
| **Mélanger tailles VMs** | Flexible orchestration | Hétérogénéité |
| **Load balancing automatique** | VMSS Uniform + Azure LB | Intégration native |
| **Installation logiciel au démarrage** | Custom Script Extension | Automatisation |
