### 3.5 Infrastructure as Code (IaC) - ARM, Bicep, Terraform

#### ARM Templates (Azure Resource Manager Templates)

**⚠️ Fondamental pour l'Examen AZ-104**

**Définition :**
ARM Templates sont des fichiers JSON déclaratifs qui définissent l'infrastructure Azure de manière programmatique (Infrastructure as Code).

**Avantages :**
- **Déclaratif** : Décrivez "quoi" déployer, pas "comment"
- **Idempotent** : Même résultat à chaque exécution
- **Orchestration** : Déploie ressources dans le bon ordre
- **Validation** : Test avant déploiement
- **Modularité** : Templates réutilisables
- **Versioning** : Intégration Git/DevOps

**Structure Complète ARM Template :**

```json
{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "description": "Déploiement VM Windows avec disques et réseau"
  },
  "parameters": {
    "vmName": {
      "type": "string",
      "defaultValue": "myVM",
      "metadata": {
        "description": "Nom de la machine virtuelle"
      }
    },
    "vmSize": {
      "type": "string",
      "defaultValue": "Standard_D2s_v3",
      "allowedValues": [
        "Standard_B2s",
        "Standard_D2s_v3",
        "Standard_D4s_v3"
      ],
      "metadata": {
        "description": "Taille de la VM"
      }
    },
    "adminUsername": {
      "type": "string",
      "metadata": {
        "description": "Nom d'utilisateur administrateur"
      }
    },
    "adminPassword": {
      "type": "securestring",
      "metadata": {
        "description": "Mot de passe administrateur"
      }
    },
    "location": {
      "type": "string",
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "Localisation des ressources"
      }
    }
  },
  "variables": {
    "vnetName": "[concat(parameters('vmName'), '-vnet')]",
    "subnetName": "default",
    "nicName": "[concat(parameters('vmName'), '-nic')]",
    "publicIPName": "[concat(parameters('vmName'), '-pip')]",
    "nsgName": "[concat(parameters('vmName'), '-nsg')]",
    "osDiskName": "[concat(parameters('vmName'), '-osdisk')]",
    "addressPrefix": "10.0.0.0/16",
    "subnetPrefix": "10.0.1.0/24"
  },
  "resources": [
    {
      "type": "Microsoft.Network/virtualNetworks",
      "apiVersion": "2023-04-01",
      "name": "[variables('vnetName')]",
      "location": "[parameters('location')]",
      "properties": {
        "addressSpace": {
          "addressPrefixes": [
            "[variables('addressPrefix')]"
          ]
        },
        "subnets": [
          {
            "name": "[variables('subnetName')]",
            "properties": {
              "addressPrefix": "[variables('subnetPrefix')]"
            }
          }
        ]
      }
    },
    {
      "type": "Microsoft.Network/publicIPAddresses",
      "apiVersion": "2023-04-01",
      "name": "[variables('publicIPName')]",
      "location": "[parameters('location')]",
      "sku": {
        "name": "Standard"
      },
      "properties": {
        "publicIPAllocationMethod": "Static"
      }
    },
    {
      "type": "Microsoft.Network/networkSecurityGroups",
      "apiVersion": "2023-04-01",
      "name": "[variables('nsgName')]",
      "location": "[parameters('location')]",
      "properties": {
        "securityRules": [
          {
            "name": "RDP",
            "properties": {
              "priority": 100,
              "protocol": "Tcp",
              "access": "Allow",
              "direction": "Inbound",
              "sourceAddressPrefix": "*",
              "sourcePortRange": "*",
              "destinationAddressPrefix": "*",
              "destinationPortRange": "3389"
            }
          }
        ]
      }
    },
    {
      "type": "Microsoft.Network/networkInterfaces",
      "apiVersion": "2023-04-01",
      "name": "[variables('nicName')]",
      "location": "[parameters('location')]",
      "dependsOn": [
        "[resourceId('Microsoft.Network/virtualNetworks', variables('vnetName'))]",
        "[resourceId('Microsoft.Network/publicIPAddresses', variables('publicIPName'))]",
        "[resourceId('Microsoft.Network/networkSecurityGroups', variables('nsgName'))]"
      ],
      "properties": {
        "ipConfigurations": [
          {
            "name": "ipconfig1",
            "properties": {
              "subnet": {
                "id": "[resourceId('Microsoft.Network/virtualNetworks/subnets', variables('vnetName'), variables('subnetName'))]"
              },
              "publicIPAddress": {
                "id": "[resourceId('Microsoft.Network/publicIPAddresses', variables('publicIPName'))]"
              }
            }
          }
        ],
        "networkSecurityGroup": {
          "id": "[resourceId('Microsoft.Network/networkSecurityGroups', variables('nsgName'))]"
        }
      }
    },
    {
      "type": "Microsoft.Compute/virtualMachines",
      "apiVersion": "2023-03-01",
      "name": "[parameters('vmName')]",
      "location": "[parameters('location')]",
      "dependsOn": [
        "[resourceId('Microsoft.Network/networkInterfaces', variables('nicName'))]"
      ],
      "properties": {
        "hardwareProfile": {
          "vmSize": "[parameters('vmSize')]"
        },
        "osProfile": {
          "computerName": "[parameters('vmName')]",
          "adminUsername": "[parameters('adminUsername')]",
          "adminPassword": "[parameters('adminPassword')]"
        },
        "storageProfile": {
          "imageReference": {
            "publisher": "MicrosoftWindowsServer",
            "offer": "WindowsServer",
            "sku": "2022-Datacenter",
            "version": "latest"
          },
          "osDisk": {
            "name": "[variables('osDiskName')]",
            "createOption": "FromImage",
            "managedDisk": {
              "storageAccountType": "Premium_LRS"
            }
          },
          "dataDisks": [
            {
              "lun": 0,
              "name": "[concat(parameters('vmName'), '-datadisk1')]",
              "createOption": "Empty",
              "diskSizeGB": 128,
              "managedDisk": {
                "storageAccountType": "Premium_LRS"
              }
            }
          ]
        },
        "networkProfile": {
          "networkInterfaces": [
            {
              "id": "[resourceId('Microsoft.Network/networkInterfaces', variables('nicName'))]"
            }
          ]
        }
      }
    }
  ],
  "outputs": {
    "vmName": {
      "type": "string",
      "value": "[parameters('vmName')]"
    },
    "publicIP": {
      "type": "string",
      "value": "[reference(resourceId('Microsoft.Network/publicIPAddresses', variables('publicIPName'))).ipAddress]"
    },
    "resourceId": {
      "type": "string",
      "value": "[resourceId('Microsoft.Compute/virtualMachines', parameters('vmName'))]"
    }
  }
}
```

**Sections du Template ARM :**

**1. `$schema` et `contentVersion` :**
- **$schema** : Définit le schéma de validation
- **contentVersion** : Version du template (pour tracking)

**2. `parameters` - Valeurs Configurables :**
```json
"parameters": {
  "vmName": {
    "type": "string",
    "defaultValue": "myVM",
    "minLength": 1,
    "maxLength": 15,
    "metadata": {
      "description": "Nom de la VM"
    }
  },
  "adminPassword": {
    "type": "securestring"
  },
  "vmSize": {
    "type": "string",
    "allowedValues": ["Standard_B2s", "Standard_D2s_v3"]
  }
}
```

**Types de paramètres :**
- `string` : Texte
- `securestring` : Mot de passe (non affiché dans logs)
- `int` : Nombre entier
- `bool` : Boolean
- `object` : Objet JSON
- `array` : Tableau
- `secureObject` : Objet sécurisé

**3. `variables` - Valeurs Calculées :**
```json
"variables": {
  "nicName": "[concat(parameters('vmName'), '-nic')]",
  "subnetRef": "[resourceId('Microsoft.Network/virtualNetworks/subnets', variables('vnetName'), variables('subnetName'))]",
  "isProduction": "[equals(parameters('environment'), 'prod')]"
}
```

**Fonctions ARM utiles :**
- `concat()` : Concaténation de chaînes
- `resourceId()` : Obtenir l'ID d'une ressource
- `reference()` : Obtenir les propriétés d'une ressource
- `parameters()` : Accéder aux paramètres
- `variables()` : Accéder aux variables
- `resourceGroup()` : Info sur le resource group
- `subscription()` : Info sur la subscription
- `uniqueString()` : Générer chaîne unique
- `equals()`, `greater()`, `less()` : Comparaisons
- `if()` : Condition ternaire

**4. `resources` - Ressources Azure :**
```json
"resources": [
  {
    "type": "Microsoft.Compute/virtualMachines",
    "apiVersion": "2023-03-01",
    "name": "[parameters('vmName')]",
    "location": "[parameters('location')]",
    "dependsOn": [
      "[resourceId('Microsoft.Network/networkInterfaces', variables('nicName'))]"
    ],
    "properties": {
      // Configuration de la ressource
    }
  }
]
```

**`dependsOn` - Ordre de Déploiement :**
- Spécifie les dépendances entre ressources
- Azure déploie les ressources dans le bon ordre
- Utilise `resourceId()` pour référencer

**5. `outputs` - Valeurs Retournées :**
```json
"outputs": {
  "publicIP": {
    "type": "string",
    "value": "[reference(resourceId('Microsoft.Network/publicIPAddresses', variables('publicIPName'))).ipAddress]"
  },
  "vmId": {
    "type": "string",
    "value": "[resourceId('Microsoft.Compute/virtualMachines', parameters('vmName'))]"
  }
}
```

**Déploiement ARM Template :**

Resources in the resource group were deleted except for the newly-created storage account because you used the -mode complete parameter with the New-AzResourceGroupDeployment cmdlet. The New-AzResourceGroupDeployment cmdlet has two deployment modes: incremental and complete. When you use the complete mode, all resources in the resource group that are not included in the template are deleted.
Using the -mode parameter with the New-AzResourceGroupDeployment cmdlet was not the cause. When you do not use the -mode parameter, you are using the default incremental deployment mode. In this mode, any resource that is not present in the template is maintained in the resource group. If a resource in the resource group is present in the template and any of these parameters in the template differ from the values in the resource group, those values are updated in the resource present in Azure. You should use this mode when deploying the template.
The cause was not the template containing the mode parameter with the value Complete or Incremental. The template that you are using does not contain any linked or nested templates, so the mode parameter should not be present in the template with either value. This parameter is part of the deployment resource type and is typically used with nested or linked templates. Complete and incremental deployment modes behave the same way as in the New-AzResourceGroupDeployment cmdlet.

**Via Azure CLI :**
```bash
# Déployer template avec paramètres inline
az deployment group create \
  --resource-group myRG \
  --template-file azuredeploy.json \
  --parameters vmName=myVM adminUsername=azureuser adminPassword='P@ssw0rd123!'

# Déployer avec fichier de paramètres
az deployment group create \
  --resource-group myRG \
  --template-file azuredeploy.json \
  --parameters @azuredeploy.parameters.json

# Valider avant déploiement (What-If)
az deployment group validate \
  --resource-group myRG \
  --template-file azuredeploy.json \
  --parameters @azuredeploy.parameters.json

# What-If - Prévisualiser changements
az deployment group what-if \
  --resource-group myRG \
  --template-file azuredeploy.json \
  --parameters @azuredeploy.parameters.json
```

**Via PowerShell :**
```powershell
# Déployer template
New-AzResourceGroupDeployment `
  -ResourceGroupName "myRG" `
  -TemplateFile "azuredeploy.json" `
  -TemplateParameterFile "azuredeploy.parameters.json" `
  -Verbose

# Test deployment (validation)
Test-AzResourceGroupDeployment `
  -ResourceGroupName "myRG" `
  -TemplateFile "azuredeploy.json" `
  -TemplateParameterFile "azuredeploy.parameters.json"

# What-If
New-AzResourceGroupDeployment `
  -ResourceGroupName "myRG" `
  -TemplateFile "azuredeploy.json" `
  -WhatIf
```

**Fichier de Paramètres (azuredeploy.parameters.json) :**
```json
{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "vmName": {
      "value": "myVM"
    },
    "vmSize": {
      "value": "Standard_D2s_v3"
    },
    "adminUsername": {
      "value": "azureuser"
    },
    "adminPassword": {
      "reference": {
        "keyVault": {
          "id": "/subscriptions/{sub-id}/resourceGroups/myRG/providers/Microsoft.KeyVault/vaults/myKeyVault"
        },
        "secretName": "vmAdminPassword"
      }
    }
  }
}
```

**Linked Templates - Modularité :**
```json
{
  "type": "Microsoft.Resources/deployments",
  "apiVersion": "2021-04-01",
  "name": "linkedDeployment",
  "properties": {
    "mode": "Incremental",
    "templateLink": {
      "uri": "https://mystorageaccount.blob.core.windows.net/templates/network.json",
      "contentVersion": "1.0.0.0"
    },
    "parameters": {
      "vnetName": {
        "value": "[variables('vnetName')]"
      }
    }
  }
}
```

**Deployment Modes :**

| Mode | Comportement | Use Case |
|------|--------------|----------|
| **Incremental** (Default) | Ajoute/modifie ressources, ne supprime pas | Ajout progressif de ressources |
| **Complete** | Supprime ressources non dans template | Déploiement complet contrôlé |

**Best Practices ARM Templates :**

✅ **À FAIRE :**
- Utiliser parameters files pour différents environnements
- Stocker passwords dans Azure Key Vault
- Utiliser `dependsOn` explicitement
- Valider avec `az deployment group validate`
- Tester avec `what-if` avant production
- Versionner templates dans Git
- Utiliser linked templates pour modularité
- Documenter avec `metadata.description`

❌ **À ÉVITER :**
- Hardcoder passwords dans templates
- Templates monolithiques (> 1000 lignes)
- Complete mode sans tester (risque suppression)
- Ignorer les erreurs de validation

#### Bicep - Alternative Moderne aux ARM Templates

**⚠️ Important pour l'Examen AZ-104**

**Définition :**
Bicep est un langage déclaratif pour déployer des ressources Azure. C'est une **abstraction simplifiée** d'ARM Templates JSON.

**Avantages Bicep vs ARM JSON :**
- ✅ **Syntaxe simplifiée** : Moins verbose (50% moins de code)
- ✅ **Type safety** : Validation au moment de l'écriture
- ✅ **Intellisense** : Support IDE (VS Code extension)
- ✅ **Modules** : Réutilisation facile
- ✅ **No state file** : Contrairement à Terraform
- ✅ **Transpilation** : Bicep → ARM JSON automatique

**Même VM en Bicep (comparaison) :**

```bicep
// Paramètres
@description('Nom de la VM')
@minLength(1)
@maxLength(15)
param vmName string = 'myVM'

@description('Taille de la VM')
@allowed([
  'Standard_B2s'
  'Standard_D2s_v3'
  'Standard_D4s_v3'
])
param vmSize string = 'Standard_D2s_v3'

@description('Nom d\'utilisateur administrateur')
param adminUsername string

@secure()
@description('Mot de passe administrateur')
param adminPassword string

param location string = resourceGroup().location

// Variables
var vnetName = '${vmName}-vnet'
var subnetName = 'default'
var nicName = '${vmName}-nic'
var publicIPName = '${vmName}-pip'
var nsgName = '${vmName}-nsg'
var osDiskName = '${vmName}-osdisk'
var addressPrefix = '10.0.0.0/16'
var subnetPrefix = '10.0.1.0/24'

// Ressources
resource vnet 'Microsoft.Network/virtualNetworks@2023-04-01' = {
  name: vnetName
  location: location
  properties: {
    addressSpace: {
      addressPrefixes: [
        addressPrefix
      ]
    }
    subnets: [
      {
        name: subnetName
        properties: {
          addressPrefix: subnetPrefix
        }
      }
    ]
  }
}

resource publicIP 'Microsoft.Network/publicIPAddresses@2023-04-01' = {
  name: publicIPName
  location: location
  sku: {
    name: 'Standard'
  }
  properties: {
    publicIPAllocationMethod: 'Static'
  }
}

resource nsg 'Microsoft.Network/networkSecurityGroups@2023-04-01' = {
  name: nsgName
  location: location
  properties: {
    securityRules: [
      {
        name: 'RDP'
        properties: {
          priority: 100
          protocol: 'Tcp'
          access: 'Allow'
          direction: 'Inbound'
          sourceAddressPrefix: '*'
          sourcePortRange: '*'
          destinationAddressPrefix: '*'
          destinationPortRange: '3389'
        }
      }
    ]
  }
}

resource nic 'Microsoft.Network/networkInterfaces@2023-04-01' = {
  name: nicName
  location: location
  properties: {
    ipConfigurations: [
      {
        name: 'ipconfig1'
        properties: {
          subnet: {
            id: vnet.properties.subnets[0].id
          }
          publicIPAddress: {
            id: publicIP.id
          }
        }
      }
    ]
    networkSecurityGroup: {
      id: nsg.id
    }
  }
}

resource vm 'Microsoft.Compute/virtualMachines@2023-03-01' = {
  name: vmName
  location: location
  properties: {
    hardwareProfile: {
      vmSize: vmSize
    }
    osProfile: {
      computerName: vmName
      adminUsername: adminUsername
      adminPassword: adminPassword
    }
    storageProfile: {
      imageReference: {
        publisher: 'MicrosoftWindowsServer'
        offer: 'WindowsServer'
        sku: '2022-Datacenter'
        version: 'latest'
      }
      osDisk: {
        name: osDiskName
        createOption: 'FromImage'
        managedDisk: {
          storageAccountType: 'Premium_LRS'
        }
      }
      dataDisks: [
        {
          lun: 0
          name: '${vmName}-datadisk1'
          createOption: 'Empty'
          diskSizeGB: 128
          managedDisk: {
            storageAccountType: 'Premium_LRS'
          }
        }
      ]
    }
    networkProfile: {
      networkInterfaces: [
        {
          id: nic.id
        }
      ]
    }
  }
}

// Outputs
output vmName string = vmName
output publicIP string = publicIP.properties.ipAddress
output vmId string = vm.id
```

**Différences Clés Bicep vs ARM JSON :**

| Feature | ARM JSON | Bicep |
|---------|----------|-------|
| **Syntaxe** | Verbeux, brackets | Concis, naturel |
| **Variables** | `[variables('name')]` | `varName` |
| **Parameters** | `[parameters('name')]` | `paramName` |
| **String concat** | `[concat('a', 'b')]` | `'${a}${b}'` |
| **Resource ID** | `[resourceId('...')]` | `resource.id` |
| **Properties** | `[reference('...').prop]` | `resource.properties.prop` |
| **Dependencies** | `dependsOn` explicite | Automatique (référence symbolique) |

**Bicep Modules - Réutilisation :**

**Module : storage.bicep**
```bicep
param storageAccountName string
param location string = resourceGroup().location

resource storageAccount 'Microsoft.Storage/storageAccounts@2023-01-01' = {
  name: storageAccountName
  location: location
  sku: {
    name: 'Standard_LRS'
  }
  kind: 'StorageV2'
}

output storageAccountId string = storageAccount.id
output primaryEndpoint string = storageAccount.properties.primaryEndpoints.blob
```

**Main template : main.bicep**
```bicep
module storage 'storage.bicep' = {
  name: 'storageDeployment'
  params: {
    storageAccountName: 'mystorageaccount'
    location: 'eastus'
  }
}

output storageId string = storage.outputs.storageAccountId
```

**Déploiement Bicep :**

```bash
# Installer Bicep CLI (si pas déjà fait)
az bicep install

# Upgrader Bicep
az bicep upgrade

# Déployer Bicep template
az deployment group create \
  --resource-group myRG \
  --template-file main.bicep \
  --parameters vmName=myVM adminUsername=azureuser adminPassword='P@ssw0rd123!'

# Build Bicep vers ARM JSON (pour inspection)
az bicep build --file main.bicep

# Decompile ARM JSON vers Bicep
az bicep decompile --file azuredeploy.json

# Valider Bicep
az deployment group validate \
  --resource-group myRG \
  --template-file main.bicep

# What-If avec Bicep
az deployment group what-if \
  --resource-group myRG \
  --template-file main.bicep
```

**Bicep Loops - Itération :**
```bicep
param vmCount int = 3

resource vms 'Microsoft.Compute/virtualMachines@2023-03-01' = [for i in range(0, vmCount): {
  name: 'vm-${i}'
  location: resourceGroup().location
  properties: {
    hardwareProfile: {
      vmSize: 'Standard_B2s'
    }
    // ... autres propriétés
  }
}]
```

**Bicep Conditions :**
```bicep
param deployPublicIP bool = true

resource publicIP 'Microsoft.Network/publicIPAddresses@2023-04-01' = if (deployPublicIP) {
  name: 'myPublicIP'
  location: resourceGroup().location
  properties: {
    publicIPAllocationMethod: 'Static'
  }
}
```

#### Terraform pour Azure

**⚠️ Moins Important pour AZ-104 mais Bon à Connaître**

**Définition :**
Terraform est un outil IaC **multi-cloud** de HashiCorp. Utilise HCL (HashiCorp Configuration Language).

**Terraform vs ARM/Bicep :**

| Feature | ARM/Bicep | Terraform |
|---------|-----------|-----------|
| **Scope** | Azure uniquement | Multi-cloud (Azure, AWS, GCP) |
| **Language** | JSON / Bicep | HCL |
| **State** | Pas de state file | State file requis |
| **Provider** | Natif Azure | AzureRM provider |
| **Modules** | Bicep modules | Terraform modules |
| **What-If** | `az deployment what-if` | `terraform plan` |
| **Validation** | Intégrée Azure | Locale |

**Même VM en Terraform :**

```hcl
# Provider configuration
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}
}

# Variables
variable "vm_name" {
  description = "Nom de la VM"
  type        = string
  default     = "myVM"
}

variable "vm_size" {
  description = "Taille de la VM"
  type        = string
  default     = "Standard_D2s_v3"
}

variable "admin_username" {
  description = "Username administrateur"
  type        = string
}

variable "admin_password" {
  description = "Password administrateur"
  type        = string
  sensitive   = true
}

variable "location" {
  description = "Localisation Azure"
  type        = string
  default     = "East US"
}

# Resource Group
resource "azurerm_resource_group" "main" {
  name     = "${var.vm_name}-rg"
  location = var.location
}

# Virtual Network
resource "azurerm_virtual_network" "main" {
  name                = "${var.vm_name}-vnet"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
}

# Subnet
resource "azurerm_subnet" "main" {
  name                 = "default"
  resource_group_name  = azurerm_resource_group.main.name
  virtual_network_name = azurerm_virtual_network.main.name
  address_prefixes     = ["10.0.1.0/24"]
}

# Public IP
resource "azurerm_public_ip" "main" {
  name                = "${var.vm_name}-pip"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  allocation_method   = "Static"
  sku                 = "Standard"
}

# Network Security Group
resource "azurerm_network_security_group" "main" {
  name                = "${var.vm_name}-nsg"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name

  security_rule {
    name                       = "RDP"
    priority                   = 100
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "3389"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }
}

# Network Interface
resource "azurerm_network_interface" "main" {
  name                = "${var.vm_name}-nic"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name

  ip_configuration {
    name                          = "ipconfig1"
    subnet_id                     = azurerm_subnet.main.id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id          = azurerm_public_ip.main.id
  }
}

# Associate NSG with NIC
resource "azurerm_network_interface_security_group_association" "main" {
  network_interface_id      = azurerm_network_interface.main.id
  network_security_group_id = azurerm_network_security_group.main.id
}

# Virtual Machine
resource "azurerm_windows_virtual_machine" "main" {
  name                = var.vm_name
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  size                = var.vm_size
  admin_username      = var.admin_username
  admin_password      = var.admin_password

  network_interface_ids = [
    azurerm_network_interface.main.id,
  ]

  os_disk {
    name                 = "${var.vm_name}-osdisk"
    caching              = "ReadWrite"
    storage_account_type = "Premium_LRS"
  }

  source_image_reference {
    publisher = "MicrosoftWindowsServer"
    offer     = "WindowsServer"
    sku       = "2022-Datacenter"
    version   = "latest"
  }
}

# Data Disk
resource "azurerm_managed_disk" "data" {
  name                 = "${var.vm_name}-datadisk1"
  location             = azurerm_resource_group.main.location
  resource_group_name  = azurerm_resource_group.main.name
  storage_account_type = "Premium_LRS"
  create_option        = "Empty"
  disk_size_gb         = 128
}

resource "azurerm_virtual_machine_data_disk_attachment" "data" {
  managed_disk_id    = azurerm_managed_disk.data.id
  virtual_machine_id = azurerm_windows_virtual_machine.main.id
  lun                = 0
  caching            = "ReadWrite"
}

# Outputs
output "vm_name" {
  value = azurerm_windows_virtual_machine.main.name
}

output "public_ip" {
  value = azurerm_public_ip.main.ip_address
}

output "vm_id" {
  value = azurerm_windows_virtual_machine.main.id
}
```

**Commandes Terraform :**

```bash
# Initialiser Terraform (télécharge providers)
terraform init

# Valider syntaxe
terraform validate

# Formater code
terraform fmt

# Prévisualiser changements (What-If)
terraform plan

# Appliquer changements
terraform apply

# Appliquer sans confirmation
terraform apply -auto-approve

# Détruire infrastructure
terraform destroy

# Afficher outputs
terraform output

# Afficher state
terraform show

# Import ressource existante
terraform import azurerm_resource_group.main /subscriptions/{sub-id}/resourceGroups/myRG
```

**Terraform State - Gestion :**

Le state file (`terraform.tfstate`) contient l'état actuel de l'infrastructure.

**🚨 AVERTISSEMENT DE SÉCURITÉ CRITIQUE 🚨**

Le fichier `terraform.tfstate` contient des **informations sensibles en clair** :
- ❌ **Mots de passe** : Admin passwords, database credentials
- ❌ **Clés d'accès** : Storage account keys, API keys
- ❌ **Secrets** : Certificats, tokens, connection strings
- ❌ **Données privées** : Private IPs, configuration détaillée

**⚠️ INTERDICTIONS ABSOLUES :**
- ❌ **NE JAMAIS** commiter `terraform.tfstate` dans Git
- ❌ **NE JAMAIS** partager le state file sans chiffrement
- ❌ **NE JAMAIS** stocker le state file en local en production
- ❌ **NE JAMAIS** exposer le state file publiquement

**Local State (⚠️ Development SEULEMENT) :**
```hcl
# State stocké localement (terraform.tfstate)
# ⚠️ ATTENTION : Contient des secrets en clair !
# ❌ Ne JAMAIS commiter dans Git !
# ✅ Ajouter à .gitignore :
#    terraform.tfstate
#    terraform.tfstate.backup
#    *.tfstate
#    *.tfstate.*
```

**Remote State (✅ RECOMMANDÉ pour Production) :**
```hcl
terraform {
  backend "azurerm" {
    resource_group_name  = "tfstate-rg"
    storage_account_name = "tfstatestorage"
    container_name       = "tfstate"
    key                  = "terraform.tfstate"
    # ✅ Utiliser avec Azure Storage chiffré
    # ✅ Activer State Locking
    # ✅ Configurer RBAC pour accès restreint
  }
}
```

**Best Practices - Sécurité State File :**

✅ **À FAIRE :**
- Utiliser **Remote State** avec Azure Storage
- Activer **State Locking** pour éviter les conflits
- Chiffrer le backend storage (**SSE activé**)
- Configurer **RBAC** pour accès restreint au state
- Utiliser **Azure Key Vault** pour les secrets
- Activer **Versioning** sur le storage account
- Sauvegarder régulièrement le state

❌ **À ÉVITER :**
- Commiter le state file dans Git
- Partager le state file par email/chat
- Laisser le state file en local
- Utiliser des secrets en dur dans les variables

**Terraform Modules :**
```hcl
# Module pour créer VMs
module "vm" {
  source = "./modules/vm"
  
  vm_name        = "myVM"
  vm_size        = "Standard_D2s_v3"
  admin_username = "azureuser"
  admin_password = var.admin_password
  location       = "East US"
}

output "vm_public_ip" {
  value = module.vm.public_ip
}
```

#### Comparaison Complète : ARM vs Bicep vs Terraform

| Critère | ARM Templates | Bicep | Terraform |
|---------|---------------|-------|-----------|
| **Format** | JSON | Bicep (DSL) | HCL |
| **Cloud** | Azure only | Azure only | Multi-cloud |
| **Verbosité** | Élevée | Faible | Moyenne |
| **Courbe apprentissage** | Élevée | Faible | Moyenne |
| **State management** | ❌ Aucun | ❌ Aucun | ✅ State file |
| **IDE Support** | Basique | ✅ Excellent (VS Code) | ✅ Excellent |
| **Modules** | Linked templates | ✅ Natif | ✅ Natif |
| **Community** | Microsoft | Microsoft | HashiCorp + Community |
| **Validation** | Azure | Azure | Locale |
| **What-If** | Oui | Oui | Plan |
| **Maturité** | +++++ | +++ | ++++ |

**Quand Utiliser Chaque Outil :**

| Scénario | Recommandation |
|----------|----------------|
| **Azure uniquement, nouveau projet** | **Bicep** |
| **Azure uniquement, legacy** | ARM Templates |
| **Multi-cloud (Azure + AWS + GCP)** | **Terraform** |
| **Équipe déjà Terraform** | Terraform |
| **Besoin validation native Azure** | ARM/Bicep |
| **Examen AZ-104** | ARM Templates + Bicep |

#### Scénarios d'Examen - IaC

**Questions Typiques AZ-104**

| Question | Réponse | Justification |
|----------|---------|---------------|
| **Déployer 100 VMs identiques** | ARM Template avec copy loop | Automatisation, consistance |
| **Resource Group configurable au déploiement** | Parameter dans template | Seul paramètre runtime disponible |
| **Réutiliser template pour Dev/Staging/Prod** | Parameters files séparés | Même template, paramètres différents |
| **Valider template sans déployer** | `az deployment group validate` ou `what-if` | Test avant production |
| **Syntaxe simplifiée vs ARM JSON** | Bicep | 50% moins de code |
| **Multi-cloud Azure + AWS** | Terraform | Support multi-cloud |
| **Export configuration ressources existantes** | `az group export --name myRG` | Générer template depuis existant |

**Export Template depuis Ressources Existantes :**

```bash
# Exporter toutes ressources d'un Resource Group
az group export \
  --name myRG \
  --output json > exported-template.json

# Exporter template d'un déploiement
az deployment group export \
  --name myDeployment \
  --resource-group myRG \
  --output json > deployment-template.json
```

```powershell
# Export via PowerShell
Export-AzResourceGroup `
  -ResourceGroupName "myRG" `
  -Path "exported-template.json" `
  -Force
```

