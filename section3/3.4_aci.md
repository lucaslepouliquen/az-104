### 3.4 Azure Container Instances (ACI)

**⚠️ Concept Clé pour AZ-104 : ACI est le moyen le plus simple et rapide d'exécuter des containers dans Azure sans gérer de serveurs**

**Définition :**
- **Azure Container Instances (ACI)** : Service serverless pour exécuter des containers Docker dans Azure
- **Pas d'infrastructure** : Aucune VM, orchestrateur, ou cluster à gérer
- **Démarrage rapide** : Containers disponibles en secondes
- **Facturation** : Pay-per-second (facturé à la seconde d'exécution)
- **Isolation** : Chaque container groupe est isolé dans son propre sandbox

**Caractéristiques Principales :**

**1. Serverless Containers**
- ✅ **Pas de gestion d'infrastructure** : Azure gère tout
- ✅ **Pas de VM à provisionner** : Containers s'exécutent directement sur l'infrastructure Azure
- ✅ **Pas d'orchestrateur requis** : Pas besoin de Kubernetes, Docker Swarm, etc.
- ✅ **Démarrage instantané** : Containers disponibles en quelques secondes

**2. Facturation à la Seconde**
- **Facturation** : Pay-per-second (facturé à la seconde d'exécution)
- **Avantage** : Coût optimal pour workloads intermittents
- **Exemple** : Container qui tourne 2h30 = facturé pour exactement 9000 secondes
- **Comparaison** : VMs = facturées à l'heure (minimum 1h même si arrêtée après 5 min)

**3. Support Multi-OS**
- **Linux containers** : Toutes les images Linux standard
- **Windows containers** : Windows Server Core, Nano Server
- **Images** : Docker Hub, Azure Container Registry (ACR), autres registries

**4. Isolation et Sécurité**
- **Isolation** : Chaque container groupe est isolé
- **Network isolation** : VNet integration possible (delegated subnet)
- **Managed Identity** : Support des identités managées Azure AD
- **Secrets** : Support Azure Key Vault pour secrets

**Architecture ACI :**

```
┌─────────────────────────────────────────┐
│      Azure Container Instances         │
├─────────────────────────────────────────┤
│  Container Group 1                     │
│  ├── Container A (nginx)                │
│  ├── Container B (app)                  │
│  └── Shared Volume (Azure Files)        │
├─────────────────────────────────────────┤
│  Container Group 2                      │
│  └── Container C (batch job)            │
└─────────────────────────────────────────┘
```

**Container Groups :**
- **Définition** : Collection de containers qui partagent ressources et réseau
- **Ressources partagées** : CPU, RAM, réseau, volumes
- **Lifecycle** : Tous les containers démarrent/arrêtent ensemble
- **Use case** : Sidecar pattern (app + logging container)

**Création d'un Container Instance :**

**Via Azure CLI :**
```bash
# Créer un container simple (Linux)
az container create \
  --resource-group myRG \
  --name mycontainer \
  --image mcr.microsoft.com/azuredocs/aci-helloworld:latest \
  --dns-name-label myapp \
  --ports 80 \
  --cpu 1 \
  --memory 1.5

# Créer avec variables d'environnement
az container create \
  --resource-group myRG \
  --name mycontainer \
  --image myregistry.azurecr.io/myapp:latest \
  --registry-login-server myregistry.azurecr.io \
  --registry-username myregistry \
  --registry-password $ACR_PASSWORD \
  --environment-variables \
    DATABASE_URL='https://mydb.azure.com' \
    API_KEY='secret123' \
  --cpu 2 \
  --memory 4

# Créer avec command override
az container create \
  --resource-group myRG \
  --name mycontainer \
  --image alpine:latest \
  --command-line "ping -c 10 8.8.8.8" \
  --restart-policy Never
```

**Via Azure Portal :**
```
Container Instances → Create → Configure:
- Container name
- Image source (Docker Hub, ACR, etc.)
- OS type (Linux/Windows)
- Size (CPU cores, Memory)
- Networking (Public IP, DNS name)
- Environment variables
- Restart policy
```

**Configuration Avancée :**

**1. Container Groups Multi-Containers :**
```bash
# Créer un container group avec plusieurs containers
az container create \
  --resource-group myRG \
  --name mycontainergroup \
  --image mcr.microsoft.com/azuredocs/aci-helloworld:latest \
  --cpu 2 \
  --memory 3 \
  --ip-address Public \
  --ports 80 \
  --container-name webapp \
  --registry-login-server myregistry.azurecr.io \
  --registry-username myregistry \
  --registry-password $ACR_PASSWORD

# Ajouter un second container au groupe (via YAML)
az container create \
  --resource-group myRG \
  --name mycontainergroup \
  --yaml container-group.yaml
```

**Fichier container-group.yaml :**
```yaml
apiVersion: 2018-10-01
location: eastus
name: mycontainergroup
properties:
  containers:
  - name: webapp
    properties:
      image: myregistry.azurecr.io/webapp:latest
      resources:
        requests:
          cpu: 1
          memoryInGb: 1.5
      ports:
      - port: 80
        protocol: TCP
  - name: sidecar
    properties:
      image: myregistry.azurecr.io/logging:latest
      resources:
        requests:
          cpu: 0.5
          memoryInGb: 0.5
  osType: Linux
  restartPolicy: Always
  ipAddress:
    type: Public
    ports:
    - protocol: tcp
      port: 80
    dnsNameLabel: myapp
```

**2. Volumes et Stockage :**

**Types de Volumes Supportés :**
- **Azure Files Share** : Partages SMB montés (persistants)
- **Git Repo** : Clone un repo Git dans le container
- **Empty Directory** : Volume temporaire (perdu à l'arrêt)
- **Secret Volume** : Secrets depuis Azure Key Vault

```bash
# Créer avec Azure Files volume
az container create \
  --resource-group myRG \
  --name mycontainer \
  --image myapp:latest \
  --azure-file-volume-share-name myshare \
  --azure-file-volume-account-name mystorageaccount \
  --azure-file-volume-account-key $STORAGE_KEY \
  --azure-file-volume-mount-path /mnt/azure \
  --cpu 1 \
  --memory 1.5

# Créer avec Git repo volume
az container create \
  --resource-group myRG \
  --name mycontainer \
  --image alpine/git:latest \
  --gitrepo-url https://github.com/Azure-Samples/aci-helloworld.git \
  --gitrepo-mount-path /mnt/repo \
  --command-line "ls /mnt/repo" \
  --restart-policy Never
```

**3. Restart Policies :**

| Policy | Comportement | Use Case |
|--------|-------------|----------|
| **Always** (Default) | Redémarre automatiquement si arrêté | Applications long-running |
| **OnFailure** | Redémarre seulement si erreur (exit code ≠ 0) | Jobs avec retry |
| **Never** | Ne redémarre jamais | Jobs batch, one-time tasks |

```bash
# Container avec restart policy Never (job batch)
az container create \
  --resource-group myRG \
  --name batchjob \
  --image myapp:latest \
  --restart-policy Never \
  --command-line "python process_data.py"
```

**4. Networking :**

**Options de Networking :**
- **Public IP** : Accès Internet public (avec DNS name label optionnel)
- **VNet Integration** : Container dans un subnet délégué (ACI subnet)
- **Private IP** : IP privée dans VNet uniquement

```bash
# Container avec IP publique et DNS name
az container create \
  --resource-group myRG \
  --name mycontainer \
  --image nginx:latest \
  --dns-name-label myapp \
  --ports 80 \
  --ip-address Public

# URL accessible : http://myapp.eastus.azurecontainer.io

# Container avec VNet integration
az container create \
  --resource-group myRG \
  --name mycontainer \
  --image myapp:latest \
  --vnet myVNet \
  --subnet aci-subnet \
  --ip-address Private
```

**⚠️ Prérequis VNet Integration :**
- Subnet délégué à `Microsoft.ContainerInstance/containerGroups`
- Subnet avec au moins 32 adresses IP (/27 minimum)
- NSG configuré pour autoriser le trafic

**5. Managed Identities :**

```bash
# Créer container avec System-Assigned Managed Identity
az container create \
  --resource-group myRG \
  --name mycontainer \
  --image myapp:latest \
  --assign-identity \
  --cpu 1 \
  --memory 1.5

# Assigner RBAC role à l'identité
az role assignment create \
  --assignee $(az container show --name mycontainer --resource-group myRG --query identity.principalId -o tsv) \
  --role "Storage Blob Data Reader" \
  --scope /subscriptions/{sub-id}/resourceGroups/myRG/providers/Microsoft.Storage/storageAccounts/mystorageaccount
```

**Limites et Quotas :**

| Ressource | Limite | Notes |
|-----------|--------|-------|
| **CPU par container** | 1-4 cores | Dépend de la région |
| **RAM par container** | 0.5-16 GB | Dépend de la région |
| **Containers par groupe** | 60 | Maximum |
| **Volumes par groupe** | 20 | Azure Files, Git, Empty, Secret |
| **Ports par groupe** | 5 | Ports TCP/UDP exposés |
| **Container groups par région** | 50 | Par défaut (augmentable) |
| **Taille image** | 15 GB | Maximum |

**Use Cases Détaillés :**

**1. Burst Workloads et Scaling Événementiel**
```
Scénario : Site e-commerce avec pic de trafic Black Friday
Solution : ACI pour gérer le trafic supplémentaire
Avantage : Démarrage en secondes, facturation à la seconde
```

**2. CI/CD Build Agents**
```
Scénario : Agents de build Azure DevOps
Solution : ACI comme agents auto-hébergés
Avantage : Pas de VM à maintenir, scaling automatique
```

**3. Jobs Batch et Data Processing**
```
Scénario : Traitement de données quotidien
Solution : Container ACI avec restart policy Never
Avantage : Coût optimal (payé seulement pendant exécution)
```

**4. Development/Testing Environnements**
```
Scénario : Environnements temporaires pour tests
Solution : ACI avec images de dev
Avantage : Création/destruction rapide, coût minimal
```

**5. Microservices Simple (sans orchestrateur)**
```
Scénario : Application simple avec 2-3 microservices
Solution : Container groups avec plusieurs containers
Avantage : Pas besoin de Kubernetes pour cas simples
```

**6. Scheduled Tasks**
```
Scénario : Tâches planifiées (cron jobs)
Solution : ACI + Azure Logic Apps / Event Grid
Avantage : Serverless, pas de VM à maintenir
```

**Monitoring et Logs :**

```bash
# Afficher les logs d'un container
az container logs \
  --resource-group myRG \
  --name mycontainer

# Suivre les logs en temps réel (tail -f)
az container attach \
  --resource-group myRG \
  --name mycontainer

# Afficher l'état et métriques
az container show \
  --resource-group myRG \
  --name mycontainer \
  --query "{Status:containers[0].instanceView.currentState.state,CPU:containers[0].resources.requests.cpu,Memory:containers[0].resources.requests.memoryInGb}"

# Lister tous les containers
az container list \
  --resource-group myRG \
  --output table
```

**Gestion du Lifecycle :**

```bash
# Démarrer un container arrêté
az container start \
  --resource-group myRG \
  --name mycontainer

# Arrêter un container
az container stop \
  --resource-group myRG \
  --name mycontainer

# Redémarrer un container
az container restart \
  --resource-group myRG \
  --name mycontainer

# Supprimer un container
az container delete \
  --resource-group myRG \
  --name mycontainer \
  --yes
```

**Comparaison ACI vs Autres Services :**

| Critère | ACI | VMs | App Service | AKS |
|---------|-----|-----|-------------|-----|
| **Démarrage** | ⚡ Secondes | ⏱️ Minutes | ⚡ Secondes | ⏱️ Minutes |
| **Gestion infrastructure** | ✅ Aucune | ❌ Complète | ✅ Aucune | ⚠️ Partielle |
| **Orchestration** | ❌ Non | ❌ Non | ❌ Non | ✅ Oui (K8s) |
| **Scaling** | ⚠️ Manuel | ⚠️ Manuel | ✅ Auto | ✅ Auto |
| **Coût (workload intermittent)** | ✅ Optimal | ❌ Élevé | ⚠️ Moyen | ❌ Élevé |
| **Multi-containers** | ✅ Oui (groups) | ✅ Oui | ❌ Non | ✅ Oui |
| **VNet Integration** | ✅ Oui | ✅ Oui | ✅ Oui | ✅ Oui |
| **Use Case** | Jobs, burst | Custom OS | Web apps | Production K8s |

**Scénarios d'Examen AZ-104 :**

**Question Type 1 : Workload Intermittent**
```
Scénario : Application qui tourne 2h/jour, besoin de démarrage rapide
Question : Quelle solution avec coût minimal et effort admin minimal ?

Réponse : Azure Container Instances ✅

Justification :
- Facturation à la seconde (optimal pour intermittent)
- Pas d'infrastructure à gérer
- Démarrage en secondes
- Pas besoin d'orchestrateur pour cas simple
```

**Question Type 2 : CI/CD Build Agents**
```
Scénario : Besoin d'agents de build pour Azure DevOps, pas de maintenance
Question : Quelle solution serverless ?

Réponse : ACI avec auto-scaling ✅

Justification :
- Pas de VM à maintenir
- Agents créés à la demande
- Coût optimal (payé seulement pendant builds)
```

**Question Type 3 : ACI vs AKS**
```
Scénario : Application simple avec 2 containers, pas de scaling complexe
Question : ACI ou AKS ?

Réponse : ACI ✅ (si pas besoin orchestration avancée)

Justification :
- ACI = Plus simple, moins de coût
- AKS = Overkill pour cas simple
- AKS = Nécessaire si besoin auto-scaling, service mesh, etc.
```

**Best Practices ACI :**

✅ **À FAIRE :**
- Utiliser **Azure Container Registry (ACR)** pour images privées
- Configurer **restart policy** appropriée (Always/OnFailure/Never)
- Utiliser **Managed Identities** pour accès sécurisé aux ressources
- Monitorer avec **Azure Monitor** et logs
- Utiliser **VNet integration** pour workloads sensibles
- Optimiser **taille images** (images légères = démarrage plus rapide)

❌ **À ÉVITER :**
- Utiliser ACI pour applications long-running 24/7 (coût élevé vs VMs)
- Hardcoder secrets dans images (utiliser Key Vault)
- Oublier de configurer restart policy (Always par défaut peut être inapproprié)
- Utiliser ACI pour workloads nécessitant orchestration complexe (préférer AKS)

